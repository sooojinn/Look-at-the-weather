# 룩엣더웨더 | Look At The Weather ☀️

<img  width="450"  alt="Image"  src="https://github.com/user-attachments/assets/ba6a7769-d7f2-49fd-b794-13fb5ec4fcef"  />

## 프로젝트 소개

> 사용자의 위치와 날씨를 기반으로 옷차림을 공유하는 패션 플랫폼

오늘의 날씨를 확인해도 이 온도에는 어떤 옷을 입어야 하는지 고민했던 적이 많습니다.

같은 지역 사람들과 오늘의 옷차림을 공유함으로써 날씨에 맞는 옷차림에 대한 고민을 줄여보자는 의도에서 기획하게 되었습니다.

## 팀원 소개 👥

<table>
  <thead>
    <tr>
      <th>FE</th>
      <th>BE</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        박수진 (<a href="https://github.com/sooojinn" target="_blank">GitHub</a>)<br>
        구장우 (<a href="https://github.com/plumpsqrl9744" target="_blank">GitHub</a>)
      </td>
      <td>
        이건희 (<a href="https://github.com/dnzp75" target="_blank">GitHub</a>)<br>
        김양선 (<a href="https://github.com/skyangs" target="_blank">GitHub</a>)
      </td>
    </tr>
  </tbody>
</table>

## 개발 기간 🗓️

- 2024.07 ~ 2024.11 : 개발
- 2024.11 ~ 2024.12 : 배포 및 유저 피드백 반영

## 기술 스택 ⚙️

<table>
  <tr>
    <th><strong>분류</strong></th>
    <th><strong>기술 / 도구</strong></th>
  </tr>
  <tr>
    <td>개발</td>
    <td>
      <img src="https://img.shields.io/badge/Next-black?style=for-the-badge&logo=next.js&logoColor=white" alt="Next JS" />
      <img src="https://img.shields.io/badge/react-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB" alt="React" />
      <img src="https://img.shields.io/badge/typescript-%23007ACC.svg?style=for-the-badge&logo=typescript&logoColor=white" alt="TypeScript" />
      <img src='https://img.shields.io/badge/Axios-5A29E4?style=for-the-badge&logo=Axios&logoColor=white' alt='axios'/>
      <img src="https://img.shields.io/badge/tailwindcss-%2338B2AC.svg?style=for-the-badge&logo=tailwind-css&logoColor=white" alt="TailwindCSS" />
    </td>
  </tr>
  <tr>
    <td>상태 관리</td>
    <td>
    <img src="https://img.shields.io/badge/zustand-FF4154?style=for-the-badge&logo=zustand&logoColor=white" alt="zustand">
    <img src="https://img.shields.io/badge/-React%20Query-FF4154?style=for-the-badge&logo=react%20query&logoColor=white" alt="React Query"/>
    </td>
  </tr>
  <tr>
    <td>툴링 & 개발 환경</td>
    <td><img src="https://img.shields.io/badge/NPM-%23CB3837.svg?style=for-the-badge&logo=npm&logoColor=white" alt="npm"/>
   <img src="https://img.shields.io/badge/Visual%20Studio%20Code-0078d7.svg?style=for-the-badge&logo=visual-studio-code&logoColor=white" alt='VS Code'/>
   </td>
  </tr>
  <tr>
    <td>협업</td>
    <td>
    <img src="https://img.shields.io/badge/git-%23F05033.svg?style=for-the-badge&logo=git&logoColor=white" alt="git"/>
    <img src="https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&logo=github&logoColor=white" alt="github"/>
    <img src="https://img.shields.io/badge/Notion-%23000000.svg?style=for-the-badge&logo=notion&logoColor=white" alt='notion'/>
    <img src="https://img.shields.io/badge/figma-%23F24E1E.svg?style=for-the-badge&logo=figma&logoColor=white" alt='figma'/>
    <img src="https://img.shields.io/badge/Google%20Meet-00897B?style=for-the-badge&logo=google-meet&logoColor=white" alt='google meet'>
    </td>
  </tr>
  <tr>
    <td>배포</td>
    <td>
    <img src="https://img.shields.io/badge/vercel-%23000000.svg?style=for-the-badge&logo=vercel&logoColor=white" alt='vercel'/>
    </td>
  </tr>
</table>

## 주요 기능 💡

<table style="width: 100%;">
  <tr>
    <th style="width: 50%;"><strong>메인 페이지</strong></th>
    <th style="width: 50%;"><strong>룩 페이지</strong></th>
  </tr>
  <tr>
    <td>
      <img width="410" alt="Image" src="https://github.com/user-attachments/assets/33a0c259-4631-497b-9952-b06cae9a1bf0" />
    </td>
    <td>
      <img width="410" alt="Image" src="https://github.com/user-attachments/assets/74aa5379-a559-4376-a2b3-bd38cae8235f" />
    </td>
  </tr>
  <tr>
    <td>
      • 사용자의 위치를 기반으로 현재 날씨 표시<br>
      • 위치를 클릭하면 위치 변경 페이지로 이동<br>
      • 위치 변경 시 해당 위치의 날씨와 게시글 노출
    </td>
    <td>
      • 지역, 날씨, 온도, 계절별 필터 검색 기능<br>
      • 기본적으로 사용자의 위치와 일치하는 게시글 노출
    </td>
  </tr>
</table>

<br>

<table style="width: 100%;">
  <tr>
    <th style="width: 50%;"><strong>글쓰기 페이지</strong></th>
    <th style="width: 50%;"><strong>상세 페이지 및 마이 페이지</strong></th>
  </tr>
  <tr>
    <td>
      <img width="410" alt="Image" src="https://github.com/user-attachments/assets/175e1d68-a39b-488e-811d-ad2a46612291" />
    </td>
    <td>
      <img width="410" alt="Image" src="https://github.com/user-attachments/assets/32819f03-0b03-458d-9ca0-5ca2422ff07b" />
    </td>
  </tr>
  <tr>
    <td>
      • 오늘의 옷차림을 소개하는 글을 쓸 수 있음<br>
      • 오늘의 날씨에 대한 태그를 선택할 수 있음
    </td>
    <td>
      • 내 게시물은 수정 및 삭제 가능<br>
      • 타 이용자의 게시물은 숨기기 또는 신고하기 가능<br>
      • 회원정보 수정, 내 게시물 목록, 내가 좋아요한 게시물 목록 조회
    </td>
  </tr>
</table>

## 담당 기능 ⚡️

1. 날씨 위젯 및 위치 변경 기능
2. 게시글 조회, 작성, 수정, 삭제, 신고, 좋아요 기능
3. 회원가입, 로그인, 회원정보 수정 등의 인증 관련 기능
4. 이미지 슬라이더, 이미지 lazy loading 기능
5. 무한 스크롤

## 트러블 슈팅 🚀

### 1. 무한 스크롤 리스트의 렌더링 최적화

**1️⃣ Problem**

![Image](https://github.com/user-attachments/assets/83776cbc-0471-429c-b359-b2c7b261acb5)

초기엔 데이터가 많지 않아 성능 문제가 크게 두드러지지 않았지만, 스크롤을 내리며 수백개의 데이터가 쌓일 경우 렌더링 지연 같은 퍼포먼스 문제가 발생할 수 있음을 예측했습니다. 200개의 모의 데이터로 테스트 해본 결과 예상대로 버벅임 현상이 발생했고, 렌더링 최적화의 필요성을 인식하게 되었습니다.

**2️⃣ Action**

- **Virtual Scroll 도입**
  TanStack의 `react-virtual` 라이브러리를 도입하여 **화면에 보이는 요소만 렌더링되도록 구현**했습니다.

![Image](https://github.com/user-attachments/assets/906bd139-4414-4cc5-86ca-cd678edf46e1)

반응형 요소인 경우 요소 높이를 동적으로 측정하기 위해 라이브러리 내장 함수인 `measureElement`를 사용하는 것이 일반적이지만 이 함수를 사용하면 스크롤을 내릴 때마다 `getBoundingClientRect` 함수가 연속적으로 호출됩니다. 리플로우(Reflow)가 자주 발생해 또다른 성능 문제가 발생할 것이라고 예측했습니다.
디자인 특성상 동일한 높이의 요소가 반복되므로 최초 렌더링 이후엔 요소의 높이를 동적으로 측정할 필요가 없다고 판단했습니다. 따라서 최초 렌더링 시 요소의 높이를 한 번만 측정하여 state에 캐시하고, 이후엔 재측정 없이 이 값을 재사용하도록 개선했습니다. 또한 resize 이벤트 발생 시 캐시를 초기화하여 재측정하도록 했습니다.

- **스크롤 위치 복원 기능 구현**
  Virtual Scroll 적용 이후, 게시물 클릭 → 상세 페이지 이동 → 뒤로가기 시 스크롤이 항상 맨 위로 초기화되는 UX 문제가 발생했습니다. 기존에는 window 객체의 스크롤 위치가 자동으로 유지됐지만, virtual scroll은 내부 컨테이너 스크롤을 기준으로 하기 때문에 브라우저가 위치를 기억하지 못하게 되었습니다.
  `History API` 를 이용해 스크롤 위치를 `history.state`에 저장하고 페이지 복귀 시 해당 위치로 복원했습니다.

**3️⃣ Result**

<img width='300' src='https://github.com/user-attachments/assets/b4a33c27-3475-46bc-a379-998dc6ddcec3'/> <img width="300" src="https://github.com/user-attachments/assets/46948eec-0658-44ca-a389-68c2784fd2b9"/>

Virtual Scroll 도입으로 인해 렌더링되는 DOM 수가 급감하면서 화면 진입 지연 및 스크롤 버벅임 현상이 사라졌고, **스크립트 실행 시간이 487ms → 50ms로 약 90% 단축**되었습니다.

[관련 포스팅 보러가기](https://www.soojinpark.co.kr/posts/projects/react-virtual)

### 2. 불필요한 날씨 API 요청 최소화

**1️⃣ Problem**

날씨 정보는 **분 단위로 자주 갱신되지 않음에도**, 위치 기반 서비스를 구현하면서 **동일한 응답을 반환하는 네트워크 요청이 반복적으로 발생**하는 문제가 있었습니다.

특히 백엔드는 **기상청의 단기예보 API**를 통해 데이터를 제공하고 있었는데, 짧은 시간 내 다수의 요청이 발생할 경우 **제공 기관의 서버에서 에러가 발생하는 경우가 종종 발생**했습니다.

이에 따라 **불필요한 API 요청을 줄이면서도 사용자에게는 가능한 최신 데이터를 제공할 수 있는 전략**이 필요했습니다.

**2️⃣ Action**

React Query를 활용해 날씨 데이터를 효율적으로 캐싱하고, **기상청 단기예보 API의 데이터 갱신 시각에 맞춰 `staleTime`을 유동적으로 설정**했습니다. 데이터 유형별로 **갱신 주기와 발표 시각을 정리**하여, 그에 맞게 캐시 만료 시간을 계산하는 함수를 작성했습니다.

- **기상청 단기예보 API 분석**
  - 시간별 날씨(1시간 기온, 하늘 상태, 강수 상태): 매 정각마다 갱신
  - 일별 날씨(일 최저/최고기온): 일 최저기온은 2시, 최고기온은 5시가 마지막 갱신(이용 가능 시간은 10분 후)
- **동적 staleTime 계산 함수 작성**
  - `calHourlyWeatherStaleTime()`: 다음 정각까지 남은 시간을 계산
  - `calDailyWeatherStaleTime()`: 다음 날 오전 2시 11분까지 남은 시간을 계산
- **위도/경도 값의 정제**
  - `Geolocation API`가 반환하는 값은 소수점 아래 오차로 인해 미세하게 바뀌며 queryKey가 바뀌는 문제가 있어, **소수점 넷째자리 이하 절사** 처리
- **React Query 설정**

```tsx
const useHourlyWeatherQuery = (geoPoint: GeoPoint | undefined) =>
  useQuery({
    queryKey: ['hourlyWeather', geoPoint?.latitude, geoPoint?.longitude],
    queryFn: () => getHourlyWeatherInfo(geoPoint),
    staleTime: calHourlyWeatherStaleTime(),
    gcTime: 1000 * 60 * 60,
    enabled: !!geoPoint,
  });

const useDailyWeatherQuery = (geoPoint: GeoPoint | undefined) =>
  useQuery({
    queryKey: ['dailyWeather', geoPoint?.latitude, geoPoint?.longitude],
    queryFn: () => getDailyWeatherInfo(geoPoint),
    staleTime: calDailyWeatherStaleTime(),
    gcTime: 1000 * 60 * 60,
    enabled: !!geoPoint,
  });
```

**3️⃣ Result**

- 기상청 API의 **갱신 주기에 맞춘 staleTime 설정**으로 불필요한 요청을 줄이고 서버 부하를 낮출 수 있었습니다.
- 사용자가 서비스를 1시간 동안 이용할 경우 시간별 날씨 API는 최대 2번 요청, 일별 날씨 API는 최대 1번 요청으로 API 요청 횟수를 대폭 줄이면서도 데이터의 최신성을 유지했습니다.

결과적으로 날씨 API 요청의 효율이 크게 개선되었고, 사용자 경험을 해치지 않으면서도 네트워크를 절약할 수 있게 되었습니다.

[관련 포스팅 보러가기](https://www.soojinpark.co.kr/posts/react/react-query-optimization-reducing-unnecessary-api-requests)

### 3. Next.js로 마이그레이션 및 SSR 적용

**1️⃣ Problem**

기존 React로만 개발된 룩엣더웨더 프로젝트를 Next.js로 마이그레이션하며 SSR을 도입하고자 했습니다. 그러나 기존 인증 구조에서는 SSR을 구현하는 데 제약이 있었습니다.

access token은 클라이언트의 private 변수에 저장되고 있었고, refresh token은 쿠키에 저장되어 있었습니다. 이는 보안적인 측면을 고려한 조치였지만, access token이 클라이언트에만 존재하다 보니 서버 컴포넌트에서 access token에 접근할 수 없다는 문제가 있었습니다. 결국 SSR 환경에서는 사용자 식별이 불가능했고, 사용자 맞춤 데이터를 렌더링할 수 없었습니다.

**2️⃣ Action**

- **access token의 저장 위치 변경**

  access token을 response body 대신 **쿠키에 저장**해 달라고 백엔드 팀원분께 요청드렸습니다. 인증 헤더로 사용자를 식별하는 방식은 그대로였기 때문에 서버 컴포넌트에서 API 요청 시 쿠키에 저장된 access token을 인증 헤더에 주입했습니다. 이렇게 하여 SSR 환경에서도 사용자 인증 정보를 포함하여 요청을 보낼 수 있었습니다.

- **API 요청 흐름 리팩토링**

  서버 컴포넌트에서는 HttpOnly 쿠키에 접근이 가능했지만, 클라이언트 컴포넌트에서는 접근이 불가능했기 때문에 Next.js 미들웨어에서 처리하는 방법을 선택했습니다.
  그러나 클라이언트에서 외부 API 서버로 직접 요청을 보내는 구조에서는 미들웨어가 개입할 수 없었습니다. 이를 해결하기 위해 API 요청이 **Next.js 서버를 거치도록 리버스 프록시 구조**를 도입했습니다.

  - Next.js의 `API Route`를 활용하여 클라이언트 요청이 `/api` 경로를 통해 내부 서버를 거치게 하였고,
  - 이 내부 서버에서는 요청 내용을 그대로 외부 API 서버로 전달하는 프록시 역할만 수행하도록 구성했습니다.

- **미들웨어에서 Authorization 헤더 자동 주입**

  `/api` 경로로 들어오는 요청 중 access token이 필요한 요청에 한해, 쿠키에서 access token을 꺼내 `Authorization` 헤더를 추가하는 로직을 **미들웨어에서 처리**하도록 구현했습니다. 이를 통해 클라이언트에서는 별도로 헤더를 설정하지 않아도 인증이 자동으로 적용되도록 만들었습니다.

**3️⃣ Result**

<img width="350" src="https://github.com/user-attachments/assets/391a89fa-d33c-4263-af1f-e6d8b4ca7166"/><img width='350' src="https://github.com/user-attachments/assets/d6f5fbc4-00a1-4a04-b3e7-9da545cb628d" />

- SSR 환경에서도 사용자 인증 기반 API 요청이 가능해졌고, 빠른 초기 렌더링으로 **LCP 속도가 3.4초에서 0.9초로 단축**되었습니다.

- API 요청을 Next.js 서버로 중계하고, 미들웨어에서 토큰을 주입하는 구조를 통해 **인증 로직을 일관성 있게 관리**할 수 있었습니다.
- 결과적으로 기존 인증 방식을 유지하면서도 SSR을 통해 사용자 맞춤형 데이터를 제공할 수 있는 구조로 개선할 수 있었습니다.

[관련 포스팅 보러가기](https://www.soojinpark.co.kr/posts/next.js/nextjs-ssr-reverse-proxy-middleware)
